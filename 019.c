//	Created by L.H.Ming on 2020/05/10.
//  Copyright © 2020 L.H.Ming. All rights reserved.

/*
設一個 nxn 的矩陣，由左而右，由上而下標示自1到 nxn 的數，讀入旋轉序列後，將該矩陣的資料輸出
陣列可以進行這些操作：直接印出、順時鐘旋轉一次並印出、逆時鐘旋轉一次並印出、上下對翻一次並印出

輸入範例：
n (矩陣長寬度變數)
function command number
(1, 2, 3, 4 一共四種command number，
1：直接印出
2：順時鐘旋轉旋轉一次並印出
3：逆時鐘旋轉一次並印出
4：上下對翻一次並印出 )
輸出範例：
(以各整數右邊接有一個空格，每n個整數換一次行為基準印出2維陣列，十位及百位數於右方空格即可，切勿將多位數用空格切開成個位數)

Sample Input
4
2
Sample Output
13 9 5 1
14 10 6 2
15 11 7 3
16 12 8 4

Sample Input
15
3
Sample Output
15 30 45 60 75 90 105 120 135 150 165 180 195 210 225
14 29 44 59 74 89 104 119 134 149 164 179 194 209 224
13 28 43 58 73 88 103 118 133 148 163 178 193 208 223
12 27 42 57 72 87 102 117 132 147 162 177 192 207 222
11 26 41 56 71 86 101 116 131 146 161 176 191 206 221
10 25 40 55 70 85 100 115 130 145 160 175 190 205 220
9 24 39 54 69 84 99 114 129 144 159 174 189 204 219
8 23 38 53 68 83 98 113 128 143 158 173 188 203 218
7 22 37 52 67 82 97 112 127 142 157 172 187 202 217
6 21 36 51 66 81 96 111 126 141 156 171 186 201 216
5 20 35 50 65 80 95 110 125 140 155 170 185 200 215
4 19 34 49 64 79 94 109 124 139 154 169 184 199 214
3 18 33 48 63 78 93 108 123 138 153 168 183 198 213
2 17 32 47 62 77 92 107 122 137 152 167 182 197 212
1 16 31 46 61 76 91 106 121 136 151 166 181 196 211
*/


/*
	解法有二：
		一：根據模式定義二維陣列, 再輸出
		二：先定義二維陣列，再根據模式輸出
*/

//	解法1
#include <stdio.h>

int main(void) {
	//初始化 & Input
	int n, mode, num = 0;
	scanf("%d\n%d", &n, &mode);
	int arr[n][n];
	
	switch(mode) {
		case 1:	//模式1
			// 	行[i]列[j]都從 0 開始
			//	|----->
			//	|----->
			//	|----->
			//	v----->
			for (int i = 0; i < n; i++) 
				for (int j = 0; j < n; j++) 
					arr[i][j] = ++ num;
			break;
		case 2: //模式2
			// 	行[i]從 0 開始，列[j]從 n-1 開始，並反轉行列順序
			//	<------
			//	| | | |
			//	| | | |
			//	| | | |
			//	| | | |
			//	| | | |
			//	v v v v
			for (int j = n-1; j >= 0; j--) 
				for (int i = 0; i < n; i++) 
					arr[i][j] = ++ num;
			break;
		case 3: //模式3
			// 	行[i]從 n-1 開始，列[j]從 0 開始，並反轉行列順序
			//	------>
			//	^ ^ ^ ^
			//	| | | |
			//	| | | |
			//	| | | |
			//	| | | |
			//	| | | |
			for (int j = 0; j < n; j++) 
				for (int i = n-1; i >= 0; i--) 
					arr[i][j] = ++ num;
			break;
		case 4: //模式4
			// 	行[i]從 n-1 開始，列[j]從 0 開始
			//	^----->
			//	|----->
			//	|----->
			//	|----->
			for (int i = n-1; i >= 0; i--) 
				for (int j = 0; j < n; j++) 
					arr[i][j] = ++ num;
			break;
	}
	
	//Output //行[i]列[j]都從 0 開始
	for (int i = 0; i < n; i++){
		for (int j = 0; j < n; j++) 
			printf("%d ", arr[i][j]);
		printf("\n");
	}	
	
	return 0;
}

//	解法2
/*
#include <stdio.h>

int main(void) {
	//初始化 & Input
	int n, mode, num = 0;
	scanf("%d\n%d", &n, &mode);
	int arr[n][n];
	
	//先定義一個二維陣列，行[i]列[j]都從 0 開始
	for (int i = 0; i < n; i++) 
		for (int j = 0; j < n; j++) 
			arr[i][j] = ++ num;
	
	switch(mode) {
		case 1:	//模式1
			// 	行[i]列[j]都從 0 開始輸出 (左上開始)
			//	|----->
			//	|----->
			//	|----->
			//	v----->
			for (int i = 0; i < n; i++) {
				for (int j = 0; j < n; j++) 
					printf("%d ", arr[i][j]);
				printf("\n");
			}
			break;
		case 2:	//模式2
			// 	行[i]從 n-1 開始，列[j]從 0 開始，並反轉行列順序輸出 (左下開始)
			//	------>
			//	^ ^ ^ ^
			//	| | | |
			//	| | | |
			//	| | | |
			//	| | | |
			//	| | | |
			for (int j = 0; j < n; j++) {
				for (int i = n-1; i >= 0; i--) 
					printf("%d ", arr[i][j]);
				printf("\n");
			}
			break;
		case 3:	//模式3
			// 	行[i]從 0 開始，列[j]從 n-1 開始，並反轉行列順序輸出 (右上開始)
			//	<------
			//	| | | |
			//	| | | |
			//	| | | |
			//	| | | |
			//	| | | |
			//	v v v v	
			for (int j = n-1; j >= 0; j--) {
				for (int i = 0; i < n; i++) 
					printf("%d ", arr[i][j]);
				printf("\n");
			}
			break;
		case 4: //模式4
			// 	行[i]從 n-1 開始，列[j]從 0 開始 (左下開始)
			//	^----->
			//	|----->
			//	|----->
			//	|----->
			for (int i = n-1; i >= 0; i--) {
				for (int j = 0; j < n; j++) 
					printf("%d ", arr[i][j]);
				printf("\n");
			}
			break;
	}
	
	return 0;
}
*/